# 연산자
* 연산자는 기초적인 내용이므로 간략하게 쓰고 넘어가자
<br></br>
<br></br>
## 연산자 우선순위
![image](https://user-images.githubusercontent.com/130421694/235109830-57924c26-189f-40f2-a6b8-0f1fe0d82b7e.png)
<br></br>
___
### 실수 줄이는 법

1. 연산자 우선순위를 외우고 이에 맞춰 코딩하기 보다는 괄호를 쓰는 것이 좋다   
  → a + b || c && a * b++ >= d | e << f & c   
  → 이런 코드를 현업에서 쓰면 문제가 생긴다   
  → 내 코드는 남도 봐야하고 나도 남이 쓴 코드를 봐야한다   
  → __사람이 코딩하는 이상 연산자 우선순위는 까먹을 수 밖에 없기 때문에__ 괄호로 우선순위를 정하는 것이 나를 위해서도 남을 위해서도 좋다
<br></br>
2. if문 같은거를 쓸때도 1문장을 쓰더라도 {}으로 해주자   
  → {}를 쓰지 않으면 __어떤 문장이 if문안에 들어가는지 안들어가는지를 착각하는__ 경우가 종종 생기고 이로 인해서 시간을 많이 잡아먹을 수 있다
<br></br>
3. 변수명을 선언할 때도 컴퓨터 자원이 적은 것이 아니라면 가급적 용도 별로 선언하자   
  → 암묵적으로 프로그래머들은 define 문으로 선언한 변수는 대문자로 쓴다
  → __직관성을 높인다__

![image](https://user-images.githubusercontent.com/130421694/235110012-84521df6-b85d-47fd-8061-1c3a57dd0a33.png)

## 대입 연산
![image](https://user-images.githubusercontent.com/130421694/235111392-bea78497-2354-40a9-9d5c-92fdfb241f0c.png)
* 연산자 오른쪽 값을 연산자 왼쪽 값에 대입
* 위 코드에서는 2와 3을 더한 5라는 값을 무작위 메모리 주소가 가리키는 곳에 대입한 것
* 그리고 변수 이름을 a로 지정해 준 것
<br></br>
<br></br>
___
## 논리 연산
* 참, 거짓으로 나뉨
* c언어에서 거짓은 0이고, 0이 아닌 값은 전부 참으로 인식한다
* if, while, for 등의 조건문에서도 0이 아니면 전부 참으로 인식하고 내부 문장을 실행한다
* __논리 연산은 앞 부분에서 조건을 충족하면 뒤 부분을 무시하고 지나간다__   
  → 아주 중요하다   
  → if( inRange(x, y) && check(arr) )   
  → 위 조건문에서 x, y는 2차원 배열 arr에서 확인하고 싶은 위치라고 할 때 isRange는 x,y가 배열 범위를 벗어나는지 확인하는 함수이다   
  → check는 arr[x][y] 값을 필요로 하는 어떤 함수라고 할 때 위처럼 쓰는 것은 문제가 없다   
  <br></br>
  → 하지만 순서가 반대가 된다면 문제가 생길 수 있다    
  → if( check(arr) && inRange(x, y) )   
  → x, y가 배열 범위를 벗어나는 위치라면 check 함수 내부에서 arr[x][y] 를 불러올 때 범위를 벗어나는 값을 불러오므로 에러가 발생한다
<br></br>
<br></br>
___
## 비트 연산
* 비트 연산은 임베디드 프로그래밍에서 아주 중요하다
* 임베디드 프로그래밍은 레지스터 값을 수정하는 연산이 많기 때문
* 데이터 시트를 보고 내가 GPIO를 제어하려는데, 0x 4002 1000 번지의 값을 수정해야 한다면 그 값을 어떤 비트만 수정해야 한다   
  → 0x 4002 1000이 가리키는 메모리 번지의 값이 만약 1111 .... 1111 이라면 모든 LED가 켜있는 것   
  → 특정 LED만 끄려면 상응하는 비트만 0으로 바꿔야한다
  
  
  1. AND : &
  + 모든 비트값 비교. 둘다 1이어야만 1. 나머지는 0  
  <br></br> 
  2. OR : |
  + 모든 비트값 비교. 둘 중 하나만 1이어도 1. 둘다 0이면 0
  <br></br>
  3. NOT : ~
  + 모든 비트값을 반대로 취함
  <br></br>
  4. XOR : 모든 비트값 비교 비교하는 두 값이 다르면 1, 같으면 0
  <br></br>
  6. BitShift : <<, >>
  + 원하는 만큼 비트를 왼쪽/오른쪽으로 이동

<br></br>
* 비트 연산이 사칙연산보다 빠르고, 2의 제곱수로 곱하거나 나누는 것은 비트 시프트 연산과 같다
  
  
